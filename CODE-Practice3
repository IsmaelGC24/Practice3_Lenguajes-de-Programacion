# chess_game.py
# Requiere: pip install python-chess

import chess
import sys

class MoveNode:
    """Nodo de √°rbol binario representando un movimiento SAN"""
    def __init__(self, san="Partida"):
        self.san = san
        self.left = None   # cadena de jugadas de blancas
        self.right = None  # cadena de jugadas de negras

    def add_move(self, san: str, is_white: bool):
        """A√±ade a la cadena izquierda si es blancas, derecha si es negras, retornando el nuevo nodo."""
        if is_white:
            if self.left is None:
                self.left = MoveNode(san)
            else:
                # Avanzar al final de la cadena de blancas
                node = self.left
                while node.left:
                    node = node.left
                node.left = MoveNode(san)
                return node.left
            return self.left
        else:
            if self.right is None:
                self.right = MoveNode(san)
            else:
                # Avanzar al final de la cadena de negras
                node = self.right
                while node.right:
                    node = node.right
                node.right = MoveNode(san)
                return node.right
            return self.right

    def display(self):
        """Imprime el √°rbol con dos ramas: izquierda para blancas, derecha para negras."""
        print(self.san)
        # Cadena de blancas
        if self.left:
            self._display_chain(self.left, prefix="", connector="‚îú‚îÄ ", direction="left")
        # Cadena de negras
        if self.right:
            self._display_chain(self.right, prefix="", connector="‚îî‚îÄ ", direction="right")

    def _display_chain(self, node, prefix, connector, direction):
        print(f"{prefix}{connector}{node.san}")
        new_prefix = prefix + ("‚îÇ  " if direction == "left" else "   ")
        # Continuar en la misma direcci√≥n
        if direction == "left" and node.left:
            self._display_chain(node.left, new_prefix, connector, direction)
        elif direction == "right" and node.right:
            self._display_chain(node.right, new_prefix, connector, direction)


def main():
    board = chess.Board()
    root = MoveNode()
    moves_san = []

    print("\n==== BIENVENIDO A CHESS ====")
    print("Introduce jugadas en SAN (e4, Nf3, O-O, ...)")
    print("Comandos:")
    print("  √°rbol     ‚Üí muestra el √°rbol binario de turnos")
    print("  resultado ‚Üí lista numerada de jugadas en SAN")
    print("  salir     ‚Üí termina la partida\n")

    while True:
        print(board.unicode(borders=True, empty_square=" "))
        prompt = "Blanca" if board.turn == chess.WHITE else "Negra"
        cmd = input(f"{prompt} > ").strip()

        if cmd.lower() == "salir":
            print("Fin de la partida.")
            break

        if cmd.lower() == "√°rbol":
            print("\nüå≥ √Årbol de movimientos:")
            root.display()
            print()
            continue

        if cmd.lower() == "resultado":
            pgn_str = ""
            for i in range(0, len(moves_san), 2):
                num = i//2 + 1
                white = moves_san[i]
                black = moves_san[i+1] if i+1 < len(moves_san) else ""
                pgn_str += f"{num}. {white} {black} "
            print("\n‚úÖ Movimientos hasta el momento:")
            print(pgn_str.strip() + "\n")
            continue

        try:
            move = board.parse_san(cmd)
        except ValueError:
            print("‚ùå Movimiento ilegal o formato incorrecto.")
            continue

        san = board.san(move)
        board.push(move)
        moves_san.append(san)

        # A√±adir al √°rbol: blancos (pares) a la izquierda, negros (impares) a la derecha
        idx = len(moves_san) - 1
        root.add_move(san, idx % 2 == 0)

    print("¬°Partida finalizada!")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(0)
